/* tslint:disable */
/* eslint-disable */
// Generated by Microsoft Kiota
import { type AdditionalDataHolder, type Parsable, type ParseNode, type SerializationWriter } from '@microsoft/kiota-abstractions';

export interface Attachment extends Entity, Parsable {
    /**
     * The MIME type.
     */
    contentType?: string;
    /**
     * true if the attachment is an inline attachment; otherwise, false.
     */
    isInline?: boolean;
    /**
     * The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z
     */
    lastModifiedDateTime?: Date;
    /**
     * The attachment's file name.
     */
    name?: string;
    /**
     * The length of the attachment in bytes.
     */
    size?: number;
}
export interface AttachmentCollectionResponse extends AdditionalDataHolder, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * The OdataNextLink property
     */
    odataNextLink?: string;
    /**
     * The value property
     */
    value?: Attachment[];
}
export type BodyType = (typeof BodyTypeObject)[keyof typeof BodyTypeObject];
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns a attachmentCollectionResponse
 */
export function createAttachmentCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) {
    return deserializeIntoAttachmentCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns a attachment
 */
export function createAttachmentFromDiscriminatorValue(parseNode: ParseNode | undefined) {
    return deserializeIntoAttachment;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns a dateTimeTimeZone
 */
export function createDateTimeTimeZoneFromDiscriminatorValue(parseNode: ParseNode | undefined) {
    return deserializeIntoDateTimeTimeZone;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns a emailAddress
 */
export function createEmailAddressFromDiscriminatorValue(parseNode: ParseNode | undefined) {
    return deserializeIntoEmailAddress;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns a entity
 */
export function createEntityFromDiscriminatorValue(parseNode: ParseNode | undefined) {
    return deserializeIntoEntity;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns a extensionCollectionResponse
 */
export function createExtensionCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) {
    return deserializeIntoExtensionCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns a extension
 */
export function createExtensionFromDiscriminatorValue(parseNode: ParseNode | undefined) {
    return deserializeIntoExtension;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns a followupFlag
 */
export function createFollowupFlagFromDiscriminatorValue(parseNode: ParseNode | undefined) {
    return deserializeIntoFollowupFlag;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns a inferenceClassification
 */
export function createInferenceClassificationFromDiscriminatorValue(parseNode: ParseNode | undefined) {
    return deserializeIntoInferenceClassification;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns a inferenceClassificationOverrideCollectionResponse
 */
export function createInferenceClassificationOverrideCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) {
    return deserializeIntoInferenceClassificationOverrideCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns a inferenceClassificationOverride
 */
export function createInferenceClassificationOverrideFromDiscriminatorValue(parseNode: ParseNode | undefined) {
    return deserializeIntoInferenceClassificationOverride;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns a internetMessageHeader
 */
export function createInternetMessageHeaderFromDiscriminatorValue(parseNode: ParseNode | undefined) {
    return deserializeIntoInternetMessageHeader;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns a itemBody
 */
export function createItemBodyFromDiscriminatorValue(parseNode: ParseNode | undefined) {
    return deserializeIntoItemBody;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns a mailFolderCollectionResponse
 */
export function createMailFolderCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) {
    return deserializeIntoMailFolderCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns a mailFolder
 */
export function createMailFolderFromDiscriminatorValue(parseNode: ParseNode | undefined) {
    return deserializeIntoMailFolder;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns a messageCollectionResponse
 */
export function createMessageCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) {
    return deserializeIntoMessageCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns a message
 */
export function createMessageFromDiscriminatorValue(parseNode: ParseNode | undefined) {
    return deserializeIntoMessage;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns a messageRuleActions
 */
export function createMessageRuleActionsFromDiscriminatorValue(parseNode: ParseNode | undefined) {
    return deserializeIntoMessageRuleActions;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns a messageRuleCollectionResponse
 */
export function createMessageRuleCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) {
    return deserializeIntoMessageRuleCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns a messageRule
 */
export function createMessageRuleFromDiscriminatorValue(parseNode: ParseNode | undefined) {
    return deserializeIntoMessageRule;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns a messageRulePredicates
 */
export function createMessageRulePredicatesFromDiscriminatorValue(parseNode: ParseNode | undefined) {
    return deserializeIntoMessageRulePredicates;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns a multiValueLegacyExtendedProperty
 */
export function createMultiValueLegacyExtendedPropertyFromDiscriminatorValue(parseNode: ParseNode | undefined) {
    return deserializeIntoMultiValueLegacyExtendedProperty;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns a outlookItem
 */
export function createOutlookItemFromDiscriminatorValue(parseNode: ParseNode | undefined) {
    return deserializeIntoOutlookItem;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns a recipient
 */
export function createRecipientFromDiscriminatorValue(parseNode: ParseNode | undefined) {
    return deserializeIntoRecipient;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns a singleValueLegacyExtendedProperty
 */
export function createSingleValueLegacyExtendedPropertyFromDiscriminatorValue(parseNode: ParseNode | undefined) {
    return deserializeIntoSingleValueLegacyExtendedProperty;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns a sizeRange
 */
export function createSizeRangeFromDiscriminatorValue(parseNode: ParseNode | undefined) {
    return deserializeIntoSizeRange;
}
export interface DateTimeTimeZone extends AdditionalDataHolder, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * A single point of time in a combined date and time representation ({date}T{time}; for example, 2017-08-29T04:00:00.0000000).
     */
    dateTime?: string;
    /**
     * Represents a time zone, for example, 'Pacific Standard Time'. See below for more possible values.
     */
    timeZone?: string;
}
/**
 * The deserialization information for the current model
 * @returns a Record<string, (node: ParseNode) => void>
 */
export function deserializeIntoAttachment(attachment: Attachment | undefined = {} as Attachment) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(attachment),
        "contentType": n => { attachment.contentType = n.getStringValue(); },
        "isInline": n => { attachment.isInline = n.getBooleanValue(); },
        "lastModifiedDateTime": n => { attachment.lastModifiedDateTime = n.getDateValue(); },
        "name": n => { attachment.name = n.getStringValue(); },
        "size": n => { attachment.size = n.getNumberValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns a Record<string, (node: ParseNode) => void>
 */
export function deserializeIntoAttachmentCollectionResponse(attachmentCollectionResponse: AttachmentCollectionResponse | undefined = {} as AttachmentCollectionResponse) : Record<string, (node: ParseNode) => void> {
    return {
        "@odata.nextLink": n => { attachmentCollectionResponse.odataNextLink = n.getStringValue(); },
        "value": n => { attachmentCollectionResponse.value = n.getCollectionOfObjectValues<Attachment>(createAttachmentFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns a Record<string, (node: ParseNode) => void>
 */
export function deserializeIntoDateTimeTimeZone(dateTimeTimeZone: DateTimeTimeZone | undefined = {} as DateTimeTimeZone) : Record<string, (node: ParseNode) => void> {
    return {
        "dateTime": n => { dateTimeTimeZone.dateTime = n.getStringValue(); },
        "timeZone": n => { dateTimeTimeZone.timeZone = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns a Record<string, (node: ParseNode) => void>
 */
export function deserializeIntoEmailAddress(emailAddress: EmailAddress | undefined = {} as EmailAddress) : Record<string, (node: ParseNode) => void> {
    return {
        "address": n => { emailAddress.address = n.getStringValue(); },
        "name": n => { emailAddress.name = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns a Record<string, (node: ParseNode) => void>
 */
export function deserializeIntoEntity(entity: Entity | undefined = {} as Entity) : Record<string, (node: ParseNode) => void> {
    return {
        "id": n => { entity.id = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns a Record<string, (node: ParseNode) => void>
 */
export function deserializeIntoExtension(extension: Extension | undefined = {} as Extension) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(extension),
    }
}
/**
 * The deserialization information for the current model
 * @returns a Record<string, (node: ParseNode) => void>
 */
export function deserializeIntoExtensionCollectionResponse(extensionCollectionResponse: ExtensionCollectionResponse | undefined = {} as ExtensionCollectionResponse) : Record<string, (node: ParseNode) => void> {
    return {
        "@odata.nextLink": n => { extensionCollectionResponse.odataNextLink = n.getStringValue(); },
        "value": n => { extensionCollectionResponse.value = n.getCollectionOfObjectValues<Extension>(createExtensionFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns a Record<string, (node: ParseNode) => void>
 */
export function deserializeIntoFollowupFlag(followupFlag: FollowupFlag | undefined = {} as FollowupFlag) : Record<string, (node: ParseNode) => void> {
    return {
        "completedDateTime": n => { followupFlag.completedDateTime = n.getObjectValue<DateTimeTimeZone>(createDateTimeTimeZoneFromDiscriminatorValue); },
        "dueDateTime": n => { followupFlag.dueDateTime = n.getObjectValue<DateTimeTimeZone>(createDateTimeTimeZoneFromDiscriminatorValue); },
        "flagStatus": n => { followupFlag.flagStatus = n.getEnumValue<FollowupFlagStatus>(FollowupFlagStatusObject); },
        "startDateTime": n => { followupFlag.startDateTime = n.getObjectValue<DateTimeTimeZone>(createDateTimeTimeZoneFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns a Record<string, (node: ParseNode) => void>
 */
export function deserializeIntoInferenceClassification(inferenceClassification: InferenceClassification | undefined = {} as InferenceClassification) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(inferenceClassification),
        "overrides": n => { inferenceClassification.overrides = n.getCollectionOfObjectValues<InferenceClassificationOverride>(createInferenceClassificationOverrideFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns a Record<string, (node: ParseNode) => void>
 */
export function deserializeIntoInferenceClassificationOverride(inferenceClassificationOverride: InferenceClassificationOverride | undefined = {} as InferenceClassificationOverride) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(inferenceClassificationOverride),
        "classifyAs": n => { inferenceClassificationOverride.classifyAs = n.getEnumValue<InferenceClassificationType>(InferenceClassificationTypeObject); },
        "senderEmailAddress": n => { inferenceClassificationOverride.senderEmailAddress = n.getObjectValue<EmailAddress>(createEmailAddressFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns a Record<string, (node: ParseNode) => void>
 */
export function deserializeIntoInferenceClassificationOverrideCollectionResponse(inferenceClassificationOverrideCollectionResponse: InferenceClassificationOverrideCollectionResponse | undefined = {} as InferenceClassificationOverrideCollectionResponse) : Record<string, (node: ParseNode) => void> {
    return {
        "@odata.nextLink": n => { inferenceClassificationOverrideCollectionResponse.odataNextLink = n.getStringValue(); },
        "value": n => { inferenceClassificationOverrideCollectionResponse.value = n.getCollectionOfObjectValues<InferenceClassificationOverride>(createInferenceClassificationOverrideFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns a Record<string, (node: ParseNode) => void>
 */
export function deserializeIntoInternetMessageHeader(internetMessageHeader: InternetMessageHeader | undefined = {} as InternetMessageHeader) : Record<string, (node: ParseNode) => void> {
    return {
        "name": n => { internetMessageHeader.name = n.getStringValue(); },
        "value": n => { internetMessageHeader.value = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns a Record<string, (node: ParseNode) => void>
 */
export function deserializeIntoItemBody(itemBody: ItemBody | undefined = {} as ItemBody) : Record<string, (node: ParseNode) => void> {
    return {
        "content": n => { itemBody.content = n.getStringValue(); },
        "contentType": n => { itemBody.contentType = n.getEnumValue<BodyType>(BodyTypeObject); },
    }
}
/**
 * The deserialization information for the current model
 * @returns a Record<string, (node: ParseNode) => void>
 */
export function deserializeIntoMailFolder(mailFolder: MailFolder | undefined = {} as MailFolder) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(mailFolder),
        "childFolderCount": n => { mailFolder.childFolderCount = n.getNumberValue(); },
        "childFolders": n => { mailFolder.childFolders = n.getCollectionOfObjectValues<MailFolder>(createMailFolderFromDiscriminatorValue); },
        "displayName": n => { mailFolder.displayName = n.getStringValue(); },
        "isHidden": n => { mailFolder.isHidden = n.getBooleanValue(); },
        "messageRules": n => { mailFolder.messageRules = n.getCollectionOfObjectValues<MessageRule>(createMessageRuleFromDiscriminatorValue); },
        "messages": n => { mailFolder.messages = n.getCollectionOfObjectValues<Message>(createMessageFromDiscriminatorValue); },
        "multiValueExtendedProperties": n => { mailFolder.multiValueExtendedProperties = n.getCollectionOfObjectValues<MultiValueLegacyExtendedProperty>(createMultiValueLegacyExtendedPropertyFromDiscriminatorValue); },
        "parentFolderId": n => { mailFolder.parentFolderId = n.getStringValue(); },
        "singleValueExtendedProperties": n => { mailFolder.singleValueExtendedProperties = n.getCollectionOfObjectValues<SingleValueLegacyExtendedProperty>(createSingleValueLegacyExtendedPropertyFromDiscriminatorValue); },
        "totalItemCount": n => { mailFolder.totalItemCount = n.getNumberValue(); },
        "unreadItemCount": n => { mailFolder.unreadItemCount = n.getNumberValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns a Record<string, (node: ParseNode) => void>
 */
export function deserializeIntoMailFolderCollectionResponse(mailFolderCollectionResponse: MailFolderCollectionResponse | undefined = {} as MailFolderCollectionResponse) : Record<string, (node: ParseNode) => void> {
    return {
        "@odata.nextLink": n => { mailFolderCollectionResponse.odataNextLink = n.getStringValue(); },
        "value": n => { mailFolderCollectionResponse.value = n.getCollectionOfObjectValues<MailFolder>(createMailFolderFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns a Record<string, (node: ParseNode) => void>
 */
export function deserializeIntoMessage(message: Message | undefined = {} as Message) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoOutlookItem(message),
        "attachments": n => { message.attachments = n.getCollectionOfObjectValues<Attachment>(createAttachmentFromDiscriminatorValue); },
        "bccRecipients": n => { message.bccRecipients = n.getCollectionOfObjectValues<Recipient>(createRecipientFromDiscriminatorValue); },
        "body": n => { message.body = n.getObjectValue<ItemBody>(createItemBodyFromDiscriminatorValue); },
        "bodyPreview": n => { message.bodyPreview = n.getStringValue(); },
        "ccRecipients": n => { message.ccRecipients = n.getCollectionOfObjectValues<Recipient>(createRecipientFromDiscriminatorValue); },
        "conversationId": n => { message.conversationId = n.getStringValue(); },
        "conversationIndex": n => { message.conversationIndex = n.getStringValue(); },
        "extensions": n => { message.extensions = n.getCollectionOfObjectValues<Extension>(createExtensionFromDiscriminatorValue); },
        "flag": n => { message.flag = n.getObjectValue<FollowupFlag>(createFollowupFlagFromDiscriminatorValue); },
        "from": n => { message.from = n.getObjectValue<Recipient>(createRecipientFromDiscriminatorValue); },
        "hasAttachments": n => { message.hasAttachments = n.getBooleanValue(); },
        "importance": n => { message.importance = n.getEnumValue<Importance>(ImportanceObject); },
        "inferenceClassification": n => { message.inferenceClassification = n.getEnumValue<InferenceClassificationType>(InferenceClassificationTypeObject); },
        "internetMessageHeaders": n => { message.internetMessageHeaders = n.getCollectionOfObjectValues<InternetMessageHeader>(createInternetMessageHeaderFromDiscriminatorValue); },
        "internetMessageId": n => { message.internetMessageId = n.getStringValue(); },
        "isDeliveryReceiptRequested": n => { message.isDeliveryReceiptRequested = n.getBooleanValue(); },
        "isDraft": n => { message.isDraft = n.getBooleanValue(); },
        "isRead": n => { message.isRead = n.getBooleanValue(); },
        "isReadReceiptRequested": n => { message.isReadReceiptRequested = n.getBooleanValue(); },
        "multiValueExtendedProperties": n => { message.multiValueExtendedProperties = n.getCollectionOfObjectValues<MultiValueLegacyExtendedProperty>(createMultiValueLegacyExtendedPropertyFromDiscriminatorValue); },
        "parentFolderId": n => { message.parentFolderId = n.getStringValue(); },
        "receivedDateTime": n => { message.receivedDateTime = n.getDateValue(); },
        "replyTo": n => { message.replyTo = n.getCollectionOfObjectValues<Recipient>(createRecipientFromDiscriminatorValue); },
        "sender": n => { message.sender = n.getObjectValue<Recipient>(createRecipientFromDiscriminatorValue); },
        "sentDateTime": n => { message.sentDateTime = n.getDateValue(); },
        "singleValueExtendedProperties": n => { message.singleValueExtendedProperties = n.getCollectionOfObjectValues<SingleValueLegacyExtendedProperty>(createSingleValueLegacyExtendedPropertyFromDiscriminatorValue); },
        "subject": n => { message.subject = n.getStringValue(); },
        "toRecipients": n => { message.toRecipients = n.getCollectionOfObjectValues<Recipient>(createRecipientFromDiscriminatorValue); },
        "uniqueBody": n => { message.uniqueBody = n.getObjectValue<ItemBody>(createItemBodyFromDiscriminatorValue); },
        "webLink": n => { message.webLink = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns a Record<string, (node: ParseNode) => void>
 */
export function deserializeIntoMessageCollectionResponse(messageCollectionResponse: MessageCollectionResponse | undefined = {} as MessageCollectionResponse) : Record<string, (node: ParseNode) => void> {
    return {
        "@odata.nextLink": n => { messageCollectionResponse.odataNextLink = n.getStringValue(); },
        "value": n => { messageCollectionResponse.value = n.getCollectionOfObjectValues<Message>(createMessageFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns a Record<string, (node: ParseNode) => void>
 */
export function deserializeIntoMessageRule(messageRule: MessageRule | undefined = {} as MessageRule) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(messageRule),
        "actions": n => { messageRule.actions = n.getObjectValue<MessageRuleActions>(createMessageRuleActionsFromDiscriminatorValue); },
        "conditions": n => { messageRule.conditions = n.getObjectValue<MessageRulePredicates>(createMessageRulePredicatesFromDiscriminatorValue); },
        "displayName": n => { messageRule.displayName = n.getStringValue(); },
        "exceptions": n => { messageRule.exceptions = n.getObjectValue<MessageRulePredicates>(createMessageRulePredicatesFromDiscriminatorValue); },
        "hasError": n => { messageRule.hasError = n.getBooleanValue(); },
        "isEnabled": n => { messageRule.isEnabled = n.getBooleanValue(); },
        "isReadOnly": n => { messageRule.isReadOnly = n.getBooleanValue(); },
        "sequence": n => { messageRule.sequence = n.getNumberValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns a Record<string, (node: ParseNode) => void>
 */
export function deserializeIntoMessageRuleActions(messageRuleActions: MessageRuleActions | undefined = {} as MessageRuleActions) : Record<string, (node: ParseNode) => void> {
    return {
        "assignCategories": n => { messageRuleActions.assignCategories = n.getCollectionOfPrimitiveValues<string>(); },
        "copyToFolder": n => { messageRuleActions.copyToFolder = n.getStringValue(); },
        "delete": n => { messageRuleActions.delete = n.getBooleanValue(); },
        "forwardAsAttachmentTo": n => { messageRuleActions.forwardAsAttachmentTo = n.getCollectionOfObjectValues<Recipient>(createRecipientFromDiscriminatorValue); },
        "forwardTo": n => { messageRuleActions.forwardTo = n.getCollectionOfObjectValues<Recipient>(createRecipientFromDiscriminatorValue); },
        "markAsRead": n => { messageRuleActions.markAsRead = n.getBooleanValue(); },
        "markImportance": n => { messageRuleActions.markImportance = n.getEnumValue<Importance>(ImportanceObject); },
        "moveToFolder": n => { messageRuleActions.moveToFolder = n.getStringValue(); },
        "permanentDelete": n => { messageRuleActions.permanentDelete = n.getBooleanValue(); },
        "redirectTo": n => { messageRuleActions.redirectTo = n.getCollectionOfObjectValues<Recipient>(createRecipientFromDiscriminatorValue); },
        "stopProcessingRules": n => { messageRuleActions.stopProcessingRules = n.getBooleanValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns a Record<string, (node: ParseNode) => void>
 */
export function deserializeIntoMessageRuleCollectionResponse(messageRuleCollectionResponse: MessageRuleCollectionResponse | undefined = {} as MessageRuleCollectionResponse) : Record<string, (node: ParseNode) => void> {
    return {
        "@odata.nextLink": n => { messageRuleCollectionResponse.odataNextLink = n.getStringValue(); },
        "value": n => { messageRuleCollectionResponse.value = n.getCollectionOfObjectValues<MessageRule>(createMessageRuleFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns a Record<string, (node: ParseNode) => void>
 */
export function deserializeIntoMessageRulePredicates(messageRulePredicates: MessageRulePredicates | undefined = {} as MessageRulePredicates) : Record<string, (node: ParseNode) => void> {
    return {
        "bodyContains": n => { messageRulePredicates.bodyContains = n.getCollectionOfPrimitiveValues<string>(); },
        "bodyOrSubjectContains": n => { messageRulePredicates.bodyOrSubjectContains = n.getCollectionOfPrimitiveValues<string>(); },
        "categories": n => { messageRulePredicates.categories = n.getCollectionOfPrimitiveValues<string>(); },
        "fromAddresses": n => { messageRulePredicates.fromAddresses = n.getCollectionOfObjectValues<Recipient>(createRecipientFromDiscriminatorValue); },
        "hasAttachments": n => { messageRulePredicates.hasAttachments = n.getBooleanValue(); },
        "headerContains": n => { messageRulePredicates.headerContains = n.getCollectionOfPrimitiveValues<string>(); },
        "importance": n => { messageRulePredicates.importance = n.getEnumValue<Importance>(ImportanceObject); },
        "isApprovalRequest": n => { messageRulePredicates.isApprovalRequest = n.getBooleanValue(); },
        "isAutomaticForward": n => { messageRulePredicates.isAutomaticForward = n.getBooleanValue(); },
        "isAutomaticReply": n => { messageRulePredicates.isAutomaticReply = n.getBooleanValue(); },
        "isEncrypted": n => { messageRulePredicates.isEncrypted = n.getBooleanValue(); },
        "isMeetingRequest": n => { messageRulePredicates.isMeetingRequest = n.getBooleanValue(); },
        "isMeetingResponse": n => { messageRulePredicates.isMeetingResponse = n.getBooleanValue(); },
        "isNonDeliveryReport": n => { messageRulePredicates.isNonDeliveryReport = n.getBooleanValue(); },
        "isPermissionControlled": n => { messageRulePredicates.isPermissionControlled = n.getBooleanValue(); },
        "isReadReceipt": n => { messageRulePredicates.isReadReceipt = n.getBooleanValue(); },
        "isSigned": n => { messageRulePredicates.isSigned = n.getBooleanValue(); },
        "isVoicemail": n => { messageRulePredicates.isVoicemail = n.getBooleanValue(); },
        "messageActionFlag": n => { messageRulePredicates.messageActionFlag = n.getEnumValue<MessageActionFlag>(MessageActionFlagObject); },
        "notSentToMe": n => { messageRulePredicates.notSentToMe = n.getBooleanValue(); },
        "recipientContains": n => { messageRulePredicates.recipientContains = n.getCollectionOfPrimitiveValues<string>(); },
        "senderContains": n => { messageRulePredicates.senderContains = n.getCollectionOfPrimitiveValues<string>(); },
        "sensitivity": n => { messageRulePredicates.sensitivity = n.getEnumValue<Sensitivity>(SensitivityObject); },
        "sentCcMe": n => { messageRulePredicates.sentCcMe = n.getBooleanValue(); },
        "sentOnlyToMe": n => { messageRulePredicates.sentOnlyToMe = n.getBooleanValue(); },
        "sentToAddresses": n => { messageRulePredicates.sentToAddresses = n.getCollectionOfObjectValues<Recipient>(createRecipientFromDiscriminatorValue); },
        "sentToMe": n => { messageRulePredicates.sentToMe = n.getBooleanValue(); },
        "sentToOrCcMe": n => { messageRulePredicates.sentToOrCcMe = n.getBooleanValue(); },
        "subjectContains": n => { messageRulePredicates.subjectContains = n.getCollectionOfPrimitiveValues<string>(); },
        "withinSizeRange": n => { messageRulePredicates.withinSizeRange = n.getObjectValue<SizeRange>(createSizeRangeFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns a Record<string, (node: ParseNode) => void>
 */
export function deserializeIntoMultiValueLegacyExtendedProperty(multiValueLegacyExtendedProperty: MultiValueLegacyExtendedProperty | undefined = {} as MultiValueLegacyExtendedProperty) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(multiValueLegacyExtendedProperty),
        "value": n => { multiValueLegacyExtendedProperty.value = n.getCollectionOfPrimitiveValues<string>(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns a Record<string, (node: ParseNode) => void>
 */
export function deserializeIntoOutlookItem(outlookItem: OutlookItem | undefined = {} as OutlookItem) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(outlookItem),
        "categories": n => { outlookItem.categories = n.getCollectionOfPrimitiveValues<string>(); },
        "changeKey": n => { outlookItem.changeKey = n.getStringValue(); },
        "createdDateTime": n => { outlookItem.createdDateTime = n.getDateValue(); },
        "lastModifiedDateTime": n => { outlookItem.lastModifiedDateTime = n.getDateValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns a Record<string, (node: ParseNode) => void>
 */
export function deserializeIntoRecipient(recipient: Recipient | undefined = {} as Recipient) : Record<string, (node: ParseNode) => void> {
    return {
        "emailAddress": n => { recipient.emailAddress = n.getObjectValue<EmailAddress>(createEmailAddressFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns a Record<string, (node: ParseNode) => void>
 */
export function deserializeIntoSingleValueLegacyExtendedProperty(singleValueLegacyExtendedProperty: SingleValueLegacyExtendedProperty | undefined = {} as SingleValueLegacyExtendedProperty) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(singleValueLegacyExtendedProperty),
        "value": n => { singleValueLegacyExtendedProperty.value = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns a Record<string, (node: ParseNode) => void>
 */
export function deserializeIntoSizeRange(sizeRange: SizeRange | undefined = {} as SizeRange) : Record<string, (node: ParseNode) => void> {
    return {
        "maximumSize": n => { sizeRange.maximumSize = n.getNumberValue(); },
        "minimumSize": n => { sizeRange.minimumSize = n.getNumberValue(); },
    }
}
export interface EmailAddress extends AdditionalDataHolder, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * The email address of the person or entity.
     */
    address?: string;
    /**
     * The display name of the person or entity.
     */
    name?: string;
}
export interface Entity extends AdditionalDataHolder, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * The unique identifier for an entity. Read-only.
     */
    id?: string;
}
export interface Extension extends Entity, Parsable {
}
export interface ExtensionCollectionResponse extends AdditionalDataHolder, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * The OdataNextLink property
     */
    odataNextLink?: string;
    /**
     * The value property
     */
    value?: Extension[];
}
export interface FollowupFlag extends AdditionalDataHolder, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * The completedDateTime property
     */
    completedDateTime?: DateTimeTimeZone;
    /**
     * The dueDateTime property
     */
    dueDateTime?: DateTimeTimeZone;
    /**
     * The flagStatus property
     */
    flagStatus?: FollowupFlagStatus;
    /**
     * The startDateTime property
     */
    startDateTime?: DateTimeTimeZone;
}
export type FollowupFlagStatus = (typeof FollowupFlagStatusObject)[keyof typeof FollowupFlagStatusObject];
export type Importance = (typeof ImportanceObject)[keyof typeof ImportanceObject];
export interface InferenceClassification extends Entity, Parsable {
    /**
     * A set of overrides for a user to always classify messages from specific senders in certain ways: focused, or other. Read-only. Nullable.
     */
    overrides?: InferenceClassificationOverride[];
}
export interface InferenceClassificationOverride extends Entity, Parsable {
    /**
     * The classifyAs property
     */
    classifyAs?: InferenceClassificationType;
    /**
     * The senderEmailAddress property
     */
    senderEmailAddress?: EmailAddress;
}
export interface InferenceClassificationOverrideCollectionResponse extends AdditionalDataHolder, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * The OdataNextLink property
     */
    odataNextLink?: string;
    /**
     * The value property
     */
    value?: InferenceClassificationOverride[];
}
export type InferenceClassificationType = (typeof InferenceClassificationTypeObject)[keyof typeof InferenceClassificationTypeObject];
export interface InternetMessageHeader extends AdditionalDataHolder, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Represents the key in a key-value pair.
     */
    name?: string;
    /**
     * The value in a key-value pair.
     */
    value?: string;
}
export interface ItemBody extends AdditionalDataHolder, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * The content of the item.
     */
    content?: string;
    /**
     * The contentType property
     */
    contentType?: BodyType;
}
export interface MailFolder extends Entity, Parsable {
    /**
     * The number of immediate child mailFolders in the current mailFolder.
     */
    childFolderCount?: number;
    /**
     * The collection of child folders in the mailFolder.
     */
    childFolders?: MailFolder[];
    /**
     * The mailFolder's display name.
     */
    displayName?: string;
    /**
     * Indicates whether the mailFolder is hidden. This property can be set only when creating the folder. Find more information in Hidden mail folders.
     */
    isHidden?: boolean;
    /**
     * The collection of rules that apply to the user's Inbox folder.
     */
    messageRules?: MessageRule[];
    /**
     * The collection of messages in the mailFolder.
     */
    messages?: Message[];
    /**
     * The collection of multi-value extended properties defined for the mailFolder. Read-only. Nullable.
     */
    multiValueExtendedProperties?: MultiValueLegacyExtendedProperty[];
    /**
     * The unique identifier for the mailFolder's parent mailFolder.
     */
    parentFolderId?: string;
    /**
     * The collection of single-value extended properties defined for the mailFolder. Read-only. Nullable.
     */
    singleValueExtendedProperties?: SingleValueLegacyExtendedProperty[];
    /**
     * The number of items in the mailFolder.
     */
    totalItemCount?: number;
    /**
     * The number of items in the mailFolder marked as unread.
     */
    unreadItemCount?: number;
}
export interface MailFolderCollectionResponse extends AdditionalDataHolder, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * The OdataNextLink property
     */
    odataNextLink?: string;
    /**
     * The value property
     */
    value?: MailFolder[];
}
export interface Message extends OutlookItem, Parsable {
    /**
     * The fileAttachment and itemAttachment attachments for the message.
     */
    attachments?: Attachment[];
    /**
     * The Bcc: recipients for the message.
     */
    bccRecipients?: Recipient[];
    /**
     * The body property
     */
    body?: ItemBody;
    /**
     * The first 255 characters of the message body. It is in text format.
     */
    bodyPreview?: string;
    /**
     * The Cc: recipients for the message.
     */
    ccRecipients?: Recipient[];
    /**
     * The ID of the conversation the email belongs to.
     */
    conversationId?: string;
    /**
     * Indicates the position of the message within the conversation.
     */
    conversationIndex?: string;
    /**
     * The collection of open extensions defined for the message. Nullable.
     */
    extensions?: Extension[];
    /**
     * The flag property
     */
    flag?: FollowupFlag;
    /**
     * The from property
     */
    from?: Recipient;
    /**
     * Indicates whether the message has attachments. This property doesn't include inline attachments, so if a message contains only inline attachments, this property is false. To verify the existence of inline attachments, parse the body property to look for a src attribute, such as <IMG src='cid:image001.jpg@01D26CD8.6C05F070'>.
     */
    hasAttachments?: boolean;
    /**
     * The importance property
     */
    importance?: Importance;
    /**
     * The inferenceClassification property
     */
    inferenceClassification?: InferenceClassificationType;
    /**
     * The internetMessageHeaders property
     */
    internetMessageHeaders?: InternetMessageHeader[];
    /**
     * The internetMessageId property
     */
    internetMessageId?: string;
    /**
     * The isDeliveryReceiptRequested property
     */
    isDeliveryReceiptRequested?: boolean;
    /**
     * The isDraft property
     */
    isDraft?: boolean;
    /**
     * The isRead property
     */
    isRead?: boolean;
    /**
     * The isReadReceiptRequested property
     */
    isReadReceiptRequested?: boolean;
    /**
     * The collection of multi-value extended properties defined for the message. Nullable.
     */
    multiValueExtendedProperties?: MultiValueLegacyExtendedProperty[];
    /**
     * The parentFolderId property
     */
    parentFolderId?: string;
    /**
     * The receivedDateTime property
     */
    receivedDateTime?: Date;
    /**
     * The replyTo property
     */
    replyTo?: Recipient[];
    /**
     * The sender property
     */
    sender?: Recipient;
    /**
     * The sentDateTime property
     */
    sentDateTime?: Date;
    /**
     * The collection of single-value extended properties defined for the message. Nullable.
     */
    singleValueExtendedProperties?: SingleValueLegacyExtendedProperty[];
    /**
     * The subject property
     */
    subject?: string;
    /**
     * The toRecipients property
     */
    toRecipients?: Recipient[];
    /**
     * The uniqueBody property
     */
    uniqueBody?: ItemBody;
    /**
     * The webLink property
     */
    webLink?: string;
}
export type MessageActionFlag = (typeof MessageActionFlagObject)[keyof typeof MessageActionFlagObject];
export interface MessageCollectionResponse extends AdditionalDataHolder, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * The OdataNextLink property
     */
    odataNextLink?: string;
    /**
     * The value property
     */
    value?: Message[];
}
export interface MessageRule extends Entity, Parsable {
    /**
     * The actions property
     */
    actions?: MessageRuleActions;
    /**
     * The conditions property
     */
    conditions?: MessageRulePredicates;
    /**
     * The display name of the rule.
     */
    displayName?: string;
    /**
     * The exceptions property
     */
    exceptions?: MessageRulePredicates;
    /**
     * Indicates whether the rule is in an error condition. Read-only.
     */
    hasError?: boolean;
    /**
     * Indicates whether the rule is enabled to be applied to messages.
     */
    isEnabled?: boolean;
    /**
     * Indicates if the rule is read-only and cannot be modified or deleted by the rules REST API.
     */
    isReadOnly?: boolean;
    /**
     * Indicates the order in which the rule is executed, among other rules.
     */
    sequence?: number;
}
export interface MessageRuleActions extends AdditionalDataHolder, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * A list of categories to be assigned to a message.
     */
    assignCategories?: string[];
    /**
     * The ID of a folder that a message is to be copied to.
     */
    copyToFolder?: string;
    /**
     * Indicates whether a message should be moved to the Deleted Items folder.
     */
    delete?: boolean;
    /**
     * The email addresses of the recipients to which a message should be forwarded as an attachment.
     */
    forwardAsAttachmentTo?: Recipient[];
    /**
     * The email addresses of the recipients to which a message should be forwarded.
     */
    forwardTo?: Recipient[];
    /**
     * Indicates whether a message should be marked as read.
     */
    markAsRead?: boolean;
    /**
     * The markImportance property
     */
    markImportance?: Importance;
    /**
     * The ID of the folder that a message will be moved to.
     */
    moveToFolder?: string;
    /**
     * Indicates whether a message should be permanently deleted and not saved to the Deleted Items folder.
     */
    permanentDelete?: boolean;
    /**
     * The email addresses to which a message should be redirected.
     */
    redirectTo?: Recipient[];
    /**
     * Indicates whether subsequent rules should be evaluated.
     */
    stopProcessingRules?: boolean;
}
export interface MessageRuleCollectionResponse extends AdditionalDataHolder, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * The OdataNextLink property
     */
    odataNextLink?: string;
    /**
     * The value property
     */
    value?: MessageRule[];
}
export interface MessageRulePredicates extends AdditionalDataHolder, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Represents the strings that should appear in the body of an incoming message in order for the condition or exception to apply.
     */
    bodyContains?: string[];
    /**
     * Represents the strings that should appear in the body or subject of an incoming message in order for the condition or exception to apply.
     */
    bodyOrSubjectContains?: string[];
    /**
     * Represents the categories that an incoming message should be labeled with in order for the condition or exception to apply.
     */
    categories?: string[];
    /**
     * Represents the specific sender email addresses of an incoming message in order for the condition or exception to apply.
     */
    fromAddresses?: Recipient[];
    /**
     * Indicates whether an incoming message must have attachments in order for the condition or exception to apply.
     */
    hasAttachments?: boolean;
    /**
     * Represents the strings that appear in the headers of an incoming message in order for the condition or exception to apply.
     */
    headerContains?: string[];
    /**
     * The importance property
     */
    importance?: Importance;
    /**
     * Indicates whether an incoming message must be an approval request in order for the condition or exception to apply.
     */
    isApprovalRequest?: boolean;
    /**
     * Indicates whether an incoming message must be automatically forwarded in order for the condition or exception to apply.
     */
    isAutomaticForward?: boolean;
    /**
     * Indicates whether an incoming message must be an auto reply in order for the condition or exception to apply.
     */
    isAutomaticReply?: boolean;
    /**
     * Indicates whether an incoming message must be encrypted in order for the condition or exception to apply.
     */
    isEncrypted?: boolean;
    /**
     * Indicates whether an incoming message must be a meeting request in order for the condition or exception to apply.
     */
    isMeetingRequest?: boolean;
    /**
     * Indicates whether an incoming message must be a meeting response in order for the condition or exception to apply.
     */
    isMeetingResponse?: boolean;
    /**
     * Indicates whether an incoming message must be a non-delivery report in order for the condition or exception to apply.
     */
    isNonDeliveryReport?: boolean;
    /**
     * Indicates whether an incoming message must be permission controlled (RMS-protected) in order for the condition or exception to apply.
     */
    isPermissionControlled?: boolean;
    /**
     * Indicates whether an incoming message must be a read receipt in order for the condition or exception to apply.
     */
    isReadReceipt?: boolean;
    /**
     * Indicates whether an incoming message must be S/MIME-signed in order for the condition or exception to apply.
     */
    isSigned?: boolean;
    /**
     * Indicates whether an incoming message must be a voice mail in order for the condition or exception to apply.
     */
    isVoicemail?: boolean;
    /**
     * The messageActionFlag property
     */
    messageActionFlag?: MessageActionFlag;
    /**
     * Indicates whether the owner of the mailbox must not be a recipient of an incoming message in order for the condition or exception to apply.
     */
    notSentToMe?: boolean;
    /**
     * Represents the strings that appear in either the toRecipients or ccRecipients properties of an incoming message in order for the condition or exception to apply.
     */
    recipientContains?: string[];
    /**
     * Represents the strings that appear in the from property of an incoming message in order for the condition or exception to apply.
     */
    senderContains?: string[];
    /**
     * The sensitivity property
     */
    sensitivity?: Sensitivity;
    /**
     * Indicates whether the owner of the mailbox must be in the ccRecipients property of an incoming message in order for the condition or exception to apply.
     */
    sentCcMe?: boolean;
    /**
     * Indicates whether the owner of the mailbox must be the only recipient in an incoming message in order for the condition or exception to apply.
     */
    sentOnlyToMe?: boolean;
    /**
     * Represents the email addresses that an incoming message must have been sent to in order for the condition or exception to apply.
     */
    sentToAddresses?: Recipient[];
    /**
     * Indicates whether the owner of the mailbox must be in the toRecipients property of an incoming message in order for the condition or exception to apply.
     */
    sentToMe?: boolean;
    /**
     * Indicates whether the owner of the mailbox must be in either a toRecipients or ccRecipients property of an incoming message in order for the condition or exception to apply.
     */
    sentToOrCcMe?: boolean;
    /**
     * Represents the strings that appear in the subject of an incoming message in order for the condition or exception to apply.
     */
    subjectContains?: string[];
    /**
     * The withinSizeRange property
     */
    withinSizeRange?: SizeRange;
}
export interface MultiValueLegacyExtendedProperty extends Entity, Parsable {
    /**
     * A collection of property values.
     */
    value?: string[];
}
export interface OutlookItem extends Entity, Parsable {
    /**
     * The categories associated with the item
     */
    categories?: string[];
    /**
     * Identifies the version of the item. Every time the item is changed, changeKey changes as well. This allows Exchange to apply changes to the correct version of the object. Read-only.
     */
    changeKey?: string;
    /**
     * The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z
     */
    createdDateTime?: Date;
    /**
     * The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z
     */
    lastModifiedDateTime?: Date;
}
export interface Recipient extends AdditionalDataHolder, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * The emailAddress property
     */
    emailAddress?: EmailAddress;
}
export type Sensitivity = (typeof SensitivityObject)[keyof typeof SensitivityObject];
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeAttachment(writer: SerializationWriter, attachment: Attachment | undefined = {} as Attachment) : void {
    serializeEntity(writer, attachment)
    writer.writeStringValue("contentType", attachment.contentType);
    writer.writeBooleanValue("isInline", attachment.isInline);
    writer.writeDateValue("lastModifiedDateTime", attachment.lastModifiedDateTime);
    writer.writeStringValue("name", attachment.name);
    writer.writeNumberValue("size", attachment.size);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeAttachmentCollectionResponse(writer: SerializationWriter, attachmentCollectionResponse: AttachmentCollectionResponse | undefined = {} as AttachmentCollectionResponse) : void {
    writer.writeStringValue("@odata.nextLink", attachmentCollectionResponse.odataNextLink);
    writer.writeCollectionOfObjectValues<Attachment>("value", attachmentCollectionResponse.value, serializeAttachment);
    writer.writeAdditionalData(attachmentCollectionResponse.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeDateTimeTimeZone(writer: SerializationWriter, dateTimeTimeZone: DateTimeTimeZone | undefined = {} as DateTimeTimeZone) : void {
    writer.writeStringValue("dateTime", dateTimeTimeZone.dateTime);
    writer.writeStringValue("timeZone", dateTimeTimeZone.timeZone);
    writer.writeAdditionalData(dateTimeTimeZone.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeEmailAddress(writer: SerializationWriter, emailAddress: EmailAddress | undefined = {} as EmailAddress) : void {
    writer.writeStringValue("address", emailAddress.address);
    writer.writeStringValue("name", emailAddress.name);
    writer.writeAdditionalData(emailAddress.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeEntity(writer: SerializationWriter, entity: Entity | undefined = {} as Entity) : void {
    writer.writeStringValue("id", entity.id);
    writer.writeAdditionalData(entity.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeExtension(writer: SerializationWriter, extension: Extension | undefined = {} as Extension) : void {
    serializeEntity(writer, extension)
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeExtensionCollectionResponse(writer: SerializationWriter, extensionCollectionResponse: ExtensionCollectionResponse | undefined = {} as ExtensionCollectionResponse) : void {
    writer.writeStringValue("@odata.nextLink", extensionCollectionResponse.odataNextLink);
    writer.writeCollectionOfObjectValues<Extension>("value", extensionCollectionResponse.value, serializeExtension);
    writer.writeAdditionalData(extensionCollectionResponse.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeFollowupFlag(writer: SerializationWriter, followupFlag: FollowupFlag | undefined = {} as FollowupFlag) : void {
    writer.writeObjectValue<DateTimeTimeZone>("completedDateTime", followupFlag.completedDateTime, serializeDateTimeTimeZone);
    writer.writeObjectValue<DateTimeTimeZone>("dueDateTime", followupFlag.dueDateTime, serializeDateTimeTimeZone);
    writer.writeEnumValue<FollowupFlagStatus>("flagStatus", followupFlag.flagStatus);
    writer.writeObjectValue<DateTimeTimeZone>("startDateTime", followupFlag.startDateTime, serializeDateTimeTimeZone);
    writer.writeAdditionalData(followupFlag.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeInferenceClassification(writer: SerializationWriter, inferenceClassification: InferenceClassification | undefined = {} as InferenceClassification) : void {
    serializeEntity(writer, inferenceClassification)
    writer.writeCollectionOfObjectValues<InferenceClassificationOverride>("overrides", inferenceClassification.overrides, serializeInferenceClassificationOverride);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeInferenceClassificationOverride(writer: SerializationWriter, inferenceClassificationOverride: InferenceClassificationOverride | undefined = {} as InferenceClassificationOverride) : void {
    serializeEntity(writer, inferenceClassificationOverride)
    writer.writeEnumValue<InferenceClassificationType>("classifyAs", inferenceClassificationOverride.classifyAs);
    writer.writeObjectValue<EmailAddress>("senderEmailAddress", inferenceClassificationOverride.senderEmailAddress, serializeEmailAddress);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeInferenceClassificationOverrideCollectionResponse(writer: SerializationWriter, inferenceClassificationOverrideCollectionResponse: InferenceClassificationOverrideCollectionResponse | undefined = {} as InferenceClassificationOverrideCollectionResponse) : void {
    writer.writeStringValue("@odata.nextLink", inferenceClassificationOverrideCollectionResponse.odataNextLink);
    writer.writeCollectionOfObjectValues<InferenceClassificationOverride>("value", inferenceClassificationOverrideCollectionResponse.value, serializeInferenceClassificationOverride);
    writer.writeAdditionalData(inferenceClassificationOverrideCollectionResponse.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeInternetMessageHeader(writer: SerializationWriter, internetMessageHeader: InternetMessageHeader | undefined = {} as InternetMessageHeader) : void {
    writer.writeStringValue("name", internetMessageHeader.name);
    writer.writeStringValue("value", internetMessageHeader.value);
    writer.writeAdditionalData(internetMessageHeader.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeItemBody(writer: SerializationWriter, itemBody: ItemBody | undefined = {} as ItemBody) : void {
    writer.writeStringValue("content", itemBody.content);
    writer.writeEnumValue<BodyType>("contentType", itemBody.contentType);
    writer.writeAdditionalData(itemBody.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeMailFolder(writer: SerializationWriter, mailFolder: MailFolder | undefined = {} as MailFolder) : void {
    serializeEntity(writer, mailFolder)
    writer.writeNumberValue("childFolderCount", mailFolder.childFolderCount);
    writer.writeCollectionOfObjectValues<MailFolder>("childFolders", mailFolder.childFolders, serializeMailFolder);
    writer.writeStringValue("displayName", mailFolder.displayName);
    writer.writeBooleanValue("isHidden", mailFolder.isHidden);
    writer.writeCollectionOfObjectValues<MessageRule>("messageRules", mailFolder.messageRules, serializeMessageRule);
    writer.writeCollectionOfObjectValues<Message>("messages", mailFolder.messages, serializeMessage);
    writer.writeCollectionOfObjectValues<MultiValueLegacyExtendedProperty>("multiValueExtendedProperties", mailFolder.multiValueExtendedProperties, serializeMultiValueLegacyExtendedProperty);
    writer.writeStringValue("parentFolderId", mailFolder.parentFolderId);
    writer.writeCollectionOfObjectValues<SingleValueLegacyExtendedProperty>("singleValueExtendedProperties", mailFolder.singleValueExtendedProperties, serializeSingleValueLegacyExtendedProperty);
    writer.writeNumberValue("totalItemCount", mailFolder.totalItemCount);
    writer.writeNumberValue("unreadItemCount", mailFolder.unreadItemCount);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeMailFolderCollectionResponse(writer: SerializationWriter, mailFolderCollectionResponse: MailFolderCollectionResponse | undefined = {} as MailFolderCollectionResponse) : void {
    writer.writeStringValue("@odata.nextLink", mailFolderCollectionResponse.odataNextLink);
    writer.writeCollectionOfObjectValues<MailFolder>("value", mailFolderCollectionResponse.value, serializeMailFolder);
    writer.writeAdditionalData(mailFolderCollectionResponse.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeMessage(writer: SerializationWriter, message: Message | undefined = {} as Message) : void {
    serializeOutlookItem(writer, message)
    writer.writeCollectionOfObjectValues<Attachment>("attachments", message.attachments, serializeAttachment);
    writer.writeCollectionOfObjectValues<Recipient>("bccRecipients", message.bccRecipients, serializeRecipient);
    writer.writeObjectValue<ItemBody>("body", message.body, serializeItemBody);
    writer.writeStringValue("bodyPreview", message.bodyPreview);
    writer.writeCollectionOfObjectValues<Recipient>("ccRecipients", message.ccRecipients, serializeRecipient);
    writer.writeStringValue("conversationId", message.conversationId);
    writer.writeStringValue("conversationIndex", message.conversationIndex);
    writer.writeCollectionOfObjectValues<Extension>("extensions", message.extensions, serializeExtension);
    writer.writeObjectValue<FollowupFlag>("flag", message.flag, serializeFollowupFlag);
    writer.writeObjectValue<Recipient>("from", message.from, serializeRecipient);
    writer.writeBooleanValue("hasAttachments", message.hasAttachments);
    writer.writeEnumValue<Importance>("importance", message.importance);
    writer.writeEnumValue<InferenceClassificationType>("inferenceClassification", message.inferenceClassification);
    writer.writeCollectionOfObjectValues<InternetMessageHeader>("internetMessageHeaders", message.internetMessageHeaders, serializeInternetMessageHeader);
    writer.writeStringValue("internetMessageId", message.internetMessageId);
    writer.writeBooleanValue("isDeliveryReceiptRequested", message.isDeliveryReceiptRequested);
    writer.writeBooleanValue("isDraft", message.isDraft);
    writer.writeBooleanValue("isRead", message.isRead);
    writer.writeBooleanValue("isReadReceiptRequested", message.isReadReceiptRequested);
    writer.writeCollectionOfObjectValues<MultiValueLegacyExtendedProperty>("multiValueExtendedProperties", message.multiValueExtendedProperties, serializeMultiValueLegacyExtendedProperty);
    writer.writeStringValue("parentFolderId", message.parentFolderId);
    writer.writeDateValue("receivedDateTime", message.receivedDateTime);
    writer.writeCollectionOfObjectValues<Recipient>("replyTo", message.replyTo, serializeRecipient);
    writer.writeObjectValue<Recipient>("sender", message.sender, serializeRecipient);
    writer.writeDateValue("sentDateTime", message.sentDateTime);
    writer.writeCollectionOfObjectValues<SingleValueLegacyExtendedProperty>("singleValueExtendedProperties", message.singleValueExtendedProperties, serializeSingleValueLegacyExtendedProperty);
    writer.writeStringValue("subject", message.subject);
    writer.writeCollectionOfObjectValues<Recipient>("toRecipients", message.toRecipients, serializeRecipient);
    writer.writeObjectValue<ItemBody>("uniqueBody", message.uniqueBody, serializeItemBody);
    writer.writeStringValue("webLink", message.webLink);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeMessageCollectionResponse(writer: SerializationWriter, messageCollectionResponse: MessageCollectionResponse | undefined = {} as MessageCollectionResponse) : void {
    writer.writeStringValue("@odata.nextLink", messageCollectionResponse.odataNextLink);
    writer.writeCollectionOfObjectValues<Message>("value", messageCollectionResponse.value, serializeMessage);
    writer.writeAdditionalData(messageCollectionResponse.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeMessageRule(writer: SerializationWriter, messageRule: MessageRule | undefined = {} as MessageRule) : void {
    serializeEntity(writer, messageRule)
    writer.writeObjectValue<MessageRuleActions>("actions", messageRule.actions, serializeMessageRuleActions);
    writer.writeObjectValue<MessageRulePredicates>("conditions", messageRule.conditions, serializeMessageRulePredicates);
    writer.writeStringValue("displayName", messageRule.displayName);
    writer.writeObjectValue<MessageRulePredicates>("exceptions", messageRule.exceptions, serializeMessageRulePredicates);
    writer.writeBooleanValue("hasError", messageRule.hasError);
    writer.writeBooleanValue("isEnabled", messageRule.isEnabled);
    writer.writeBooleanValue("isReadOnly", messageRule.isReadOnly);
    writer.writeNumberValue("sequence", messageRule.sequence);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeMessageRuleActions(writer: SerializationWriter, messageRuleActions: MessageRuleActions | undefined = {} as MessageRuleActions) : void {
    writer.writeCollectionOfPrimitiveValues<string>("assignCategories", messageRuleActions.assignCategories);
    writer.writeStringValue("copyToFolder", messageRuleActions.copyToFolder);
    writer.writeBooleanValue("delete", messageRuleActions.delete);
    writer.writeCollectionOfObjectValues<Recipient>("forwardAsAttachmentTo", messageRuleActions.forwardAsAttachmentTo, serializeRecipient);
    writer.writeCollectionOfObjectValues<Recipient>("forwardTo", messageRuleActions.forwardTo, serializeRecipient);
    writer.writeBooleanValue("markAsRead", messageRuleActions.markAsRead);
    writer.writeEnumValue<Importance>("markImportance", messageRuleActions.markImportance);
    writer.writeStringValue("moveToFolder", messageRuleActions.moveToFolder);
    writer.writeBooleanValue("permanentDelete", messageRuleActions.permanentDelete);
    writer.writeCollectionOfObjectValues<Recipient>("redirectTo", messageRuleActions.redirectTo, serializeRecipient);
    writer.writeBooleanValue("stopProcessingRules", messageRuleActions.stopProcessingRules);
    writer.writeAdditionalData(messageRuleActions.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeMessageRuleCollectionResponse(writer: SerializationWriter, messageRuleCollectionResponse: MessageRuleCollectionResponse | undefined = {} as MessageRuleCollectionResponse) : void {
    writer.writeStringValue("@odata.nextLink", messageRuleCollectionResponse.odataNextLink);
    writer.writeCollectionOfObjectValues<MessageRule>("value", messageRuleCollectionResponse.value, serializeMessageRule);
    writer.writeAdditionalData(messageRuleCollectionResponse.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeMessageRulePredicates(writer: SerializationWriter, messageRulePredicates: MessageRulePredicates | undefined = {} as MessageRulePredicates) : void {
    writer.writeCollectionOfPrimitiveValues<string>("bodyContains", messageRulePredicates.bodyContains);
    writer.writeCollectionOfPrimitiveValues<string>("bodyOrSubjectContains", messageRulePredicates.bodyOrSubjectContains);
    writer.writeCollectionOfPrimitiveValues<string>("categories", messageRulePredicates.categories);
    writer.writeCollectionOfObjectValues<Recipient>("fromAddresses", messageRulePredicates.fromAddresses, serializeRecipient);
    writer.writeBooleanValue("hasAttachments", messageRulePredicates.hasAttachments);
    writer.writeCollectionOfPrimitiveValues<string>("headerContains", messageRulePredicates.headerContains);
    writer.writeEnumValue<Importance>("importance", messageRulePredicates.importance);
    writer.writeBooleanValue("isApprovalRequest", messageRulePredicates.isApprovalRequest);
    writer.writeBooleanValue("isAutomaticForward", messageRulePredicates.isAutomaticForward);
    writer.writeBooleanValue("isAutomaticReply", messageRulePredicates.isAutomaticReply);
    writer.writeBooleanValue("isEncrypted", messageRulePredicates.isEncrypted);
    writer.writeBooleanValue("isMeetingRequest", messageRulePredicates.isMeetingRequest);
    writer.writeBooleanValue("isMeetingResponse", messageRulePredicates.isMeetingResponse);
    writer.writeBooleanValue("isNonDeliveryReport", messageRulePredicates.isNonDeliveryReport);
    writer.writeBooleanValue("isPermissionControlled", messageRulePredicates.isPermissionControlled);
    writer.writeBooleanValue("isReadReceipt", messageRulePredicates.isReadReceipt);
    writer.writeBooleanValue("isSigned", messageRulePredicates.isSigned);
    writer.writeBooleanValue("isVoicemail", messageRulePredicates.isVoicemail);
    writer.writeEnumValue<MessageActionFlag>("messageActionFlag", messageRulePredicates.messageActionFlag);
    writer.writeBooleanValue("notSentToMe", messageRulePredicates.notSentToMe);
    writer.writeCollectionOfPrimitiveValues<string>("recipientContains", messageRulePredicates.recipientContains);
    writer.writeCollectionOfPrimitiveValues<string>("senderContains", messageRulePredicates.senderContains);
    writer.writeEnumValue<Sensitivity>("sensitivity", messageRulePredicates.sensitivity);
    writer.writeBooleanValue("sentCcMe", messageRulePredicates.sentCcMe);
    writer.writeBooleanValue("sentOnlyToMe", messageRulePredicates.sentOnlyToMe);
    writer.writeCollectionOfObjectValues<Recipient>("sentToAddresses", messageRulePredicates.sentToAddresses, serializeRecipient);
    writer.writeBooleanValue("sentToMe", messageRulePredicates.sentToMe);
    writer.writeBooleanValue("sentToOrCcMe", messageRulePredicates.sentToOrCcMe);
    writer.writeCollectionOfPrimitiveValues<string>("subjectContains", messageRulePredicates.subjectContains);
    writer.writeObjectValue<SizeRange>("withinSizeRange", messageRulePredicates.withinSizeRange, serializeSizeRange);
    writer.writeAdditionalData(messageRulePredicates.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeMultiValueLegacyExtendedProperty(writer: SerializationWriter, multiValueLegacyExtendedProperty: MultiValueLegacyExtendedProperty | undefined = {} as MultiValueLegacyExtendedProperty) : void {
    serializeEntity(writer, multiValueLegacyExtendedProperty)
    writer.writeCollectionOfPrimitiveValues<string>("value", multiValueLegacyExtendedProperty.value);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeOutlookItem(writer: SerializationWriter, outlookItem: OutlookItem | undefined = {} as OutlookItem) : void {
    serializeEntity(writer, outlookItem)
    writer.writeCollectionOfPrimitiveValues<string>("categories", outlookItem.categories);
    writer.writeStringValue("changeKey", outlookItem.changeKey);
    writer.writeDateValue("createdDateTime", outlookItem.createdDateTime);
    writer.writeDateValue("lastModifiedDateTime", outlookItem.lastModifiedDateTime);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeRecipient(writer: SerializationWriter, recipient: Recipient | undefined = {} as Recipient) : void {
    writer.writeObjectValue<EmailAddress>("emailAddress", recipient.emailAddress, serializeEmailAddress);
    writer.writeAdditionalData(recipient.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeSingleValueLegacyExtendedProperty(writer: SerializationWriter, singleValueLegacyExtendedProperty: SingleValueLegacyExtendedProperty | undefined = {} as SingleValueLegacyExtendedProperty) : void {
    serializeEntity(writer, singleValueLegacyExtendedProperty)
    writer.writeStringValue("value", singleValueLegacyExtendedProperty.value);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeSizeRange(writer: SerializationWriter, sizeRange: SizeRange | undefined = {} as SizeRange) : void {
    writer.writeNumberValue("maximumSize", sizeRange.maximumSize);
    writer.writeNumberValue("minimumSize", sizeRange.minimumSize);
    writer.writeAdditionalData(sizeRange.additionalData);
}
export interface SingleValueLegacyExtendedProperty extends Entity, Parsable {
    /**
     * A property value.
     */
    value?: string;
}
export interface SizeRange extends AdditionalDataHolder, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * The maximum size (in kilobytes) that an incoming message must have in order for a condition or exception to apply.
     */
    maximumSize?: number;
    /**
     * The minimum size (in kilobytes) that an incoming message must have in order for a condition or exception to apply.
     */
    minimumSize?: number;
}
export const BodyTypeObject = {
    Text: "text",
    Html: "html",
}  as const;
export const FollowupFlagStatusObject = {
    NotFlagged: "notFlagged",
    Complete: "complete",
    Flagged: "flagged",
}  as const;
export const ImportanceObject = {
    Low: "low",
    Normal: "normal",
    High: "high",
}  as const;
export const InferenceClassificationTypeObject = {
    Focused: "focused",
    Other: "other",
}  as const;
export const MessageActionFlagObject = {
    Any: "any",
    Call: "call",
    DoNotForward: "doNotForward",
    FollowUp: "followUp",
    Fyi: "fyi",
    Forward: "forward",
    NoResponseNecessary: "noResponseNecessary",
    Read: "read",
    Reply: "reply",
    ReplyToAll: "replyToAll",
    Review: "review",
}  as const;
export const SensitivityObject = {
    Normal: "normal",
    Personal: "personal",
    Private: "private",
    Confidential: "confidential",
}  as const;
/* tslint:enable */
/* eslint-enable */
